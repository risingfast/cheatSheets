C++ CheatSheet

History of Versions
    Each release is a language standard or language specification
    1979 Original compiler at Bell Labs (Bjarne Stroustrup)
    1975 C with Classes
    1983 C++ created
    1985 C++98 First standardized version
    1998 ISO standard C++
    2003 C++03 Minor update to ISO standard C++
    2011 C++11 (C++1x) Major updates and new features
    2014 C++14 (C++1y)
    2017 C++17 (C++1z) use compiler flag --std=C++17 to force usage
    2020 C++20 (C++2a)
    2023 C++23 (C++2b) Future release as of 2022

Conferences
    https://cppcon.org/

Resources and References
    https://www.cplusplus.com/doc/tutorial/ -- Tutorial and resources
    https://www.learncpp.com/ -- C++ tutorial site
    https://en.cppreference.com/w/ -- C++ Reference
    https://www.youtube.com/watch?v=8jLOx1hD3_o -- + Programming Course - Beginner to Advanced
    https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1132/ -- Stanford Class CS106B Pogramming Abstractions
    http://lib.daemon.am/Books/C++/ - Sams Teach Yourself C++ in 21 Days
    https://www.doc.ic.ac.uk/~wjk/c++intro/CourseStructure.html#S5
    https://www.cs.purdue.edu/homes/bxd/CandC++/ -- Purdue exercises
    https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-096-introduction-to-c-january-iap-2011/lecture-notes/ -- MIT C++ Lecture Notes
    https://erlerobotics.gitbooks.io/erle-robotics-cpp-gitbook/content/index.html -- Exercies and book
    https://www.codesdope.com/cpp-introduction/ -- c++ Course and exercises
    http://csit.parkland.edu/~dbock/Class/csc125/Lecture/ -- Parkland College C++ lectures
    http://csit.parkland.edu/~dbock/Class/csc125/ -- Parkland College C++ class schedule
    https://www.tutorialspoint.com/cplusplus/ -- Tutorialspoint C++ tutorial set
    https://google.github.io/styleguide/cppguide.html#C++_Version -- Google C++ Coding Standards
    https://www.engineer4free.com/cplusplus.html -- Engineer4Free C++ Full Course

Microsoft
    https://learn.microsoft.com/en-us/visualstudio/get-started/visual-studio-ide?view=vs-2022 -- What is Visual Studio?

C++ Code Beauty (code prefix cb)
    https://www.youtube.com/watch?v=GQp1zzTwrIg -- C++ FULL COURSE For Beginners (Learn C++ in 10 hours)

C++ Programming Course 30 Hours freeCodeCamp Daniel Gakwaya (code prefix dg)
    https://www.youtube.com/watch?v=8jLOx1hD3_o -- + Programming Course - Beginner to Advanced, freeCodeCamp.org, Daniel Gakwaya 31 hour single video 31:07:29

C++ Text Course LEARN C++ (code prefix ap)
    https://www.learncpp.com/ -- C++ language tutorials by chapter and topic (code reference 

C++ Cplusplus.com Tutorials (code prefix cp)
    https://www.cplusplus.com/doc/tutorial/ -- C++ language tutorials
    https://www.cplusplus.com/doc/tutorial/functions2/ -- overloads and templates
    https://www.cplusplus.com/doc/tutorial/namespaces/ -- namespaces

C++ Debbie (Deborah) Sorrentino NCCC Classes (code prefix ds)
    https://www.youtube.com/playlist?list=PL2W5ji2ambpd28htZ7PTkOuwvQ5s7NKV2 -- Playlist for C++ Programming Tutorials
    https://www.youtube.com/watch?v=bjja9aPmQn8 -- Welcome to My C++ Programming Videos
    https://www.youtube.com/watch?v=0uQKemgUJbY -- How to Create and Run a C++ Program in Visual Studio 2017 
    https://www.youtube.com/watch?v=BUqnYYGSBow -- Math Library Functions - pow, sqrt
    https://www.youtube.com/watch?v=GYaZ_FWDkk8 -- Formatting Output - left, right, setfill
    https://www.youtube.com/watch?v=dg8iRFDX93E -- String Input with getline
    https://www.youtube.com/watch?v=C_3xHf99Ku0 -- Formatting Output - setw
    https://www.youtube.com/watch?v=daBz8vFaCKo -- Formatting Output - fixed, showpoint, setprecision
    https://www.youtube.com/watch?v=BqRCu1sZ9HU -- Decision Statements - if, if..else, if..else if
    https://www.youtube.com/watch?v=WqKP9J-N0Jg -- Logical Operators - checking ranges of values
    https://www.youtube.com/watch?v=f0fZTOg7QBE -- Switch Statement
    https://www.youtube.com/watch?v=mK2GEeu0AHI -- For Loop
    https://www.youtube.com/watch?v=i9vph2_g2E4 -- While Loop
    https://www.youtube.com/watch?v=-HjWUA8nM3s -- Do .. while loop
    https://www.youtube.com/watch?v=p3WwMKtwE3A -- Output Files
    https://www.youtube.com/watch?v=_GgXDcvxGf0 -- Input Files
    https://www.youtube.com/watch?v=u2N3Foeo6oM -- Function Terminology
    https://www.youtube.com/watch?v=NawS6uNMldI -- Void Functions
    https://www.youtube.com/watch?v=H3OFaO0TQMY -- Void Functions and Value Parameters
    https://www.youtube.com/watch?v=2e85WWvT2ls -- Value Returning Functions
    https://www.youtube.com/watch?v=FBJQEXbgioY -- Writing a Program One Function at a Time
    https://www.youtube.com/watch?v=C77jvFsYuYE -- Void Functions with Reference Parameters
    https://www.youtube.com/watch?v=GNHqklR0Y4w -- Value Returning Functions
    https://www.youtube.com/watch?v=IWC7-JYunRI -- Void Functions - value and reference parameters
    https://www.youtube.com/watch?v=6OvnMHW9Xfs -- C++ Classes - Part 1
    https://www.youtube.com/watch?v=65UaMymQlpc -- C++ Classes - Part 2
    https://www.youtube.com/watch?v=iGA5BaMCRHE -- C++ Classes - Part 3
    https://www.youtube.com/watch?v=P-KPXg_oixU -- C++ Classes - Part 4
    https://www.youtube.com/watch?v=-v6qWUC7dLQ -- Rectangle Class - One File
    https://www.youtube.com/watch?v=cttbbHOlKeE -- Rectangle Class - Three Files
    https://www.youtube.com/watch?v=948lx2MKH88 -- Default Constructors
    https://www.youtube.com/watch?v=cNzcvoKIsls -- Constant Member Functions
    https://www.youtube.com/watch?v=_xjQ4cnqbxA -- Passig Objects as Parameters
    https://www.youtube.com/watch?v=zsFoWev-Ei8 -- Constant Reference Parameters - Class Objects
    https://www.youtube.com/watch?v=5fjss3AGxwo -- Inventory Class - with Include Guard
    https://www.youtube.com/watch?v=ZbtgDiQ_Yz4 -- get and ignore functions
    https://www.youtube.com/watch?v=63EOL-fHVtY -- Nested Structures
    https://www.youtube.com/watch?v=xikbFTzk5kE -- Constructors
    https://www.youtube.com/watch?v=OViyaM_ITf8 -- Storing and Displaying Data in an Array
    https://www.youtube.com/watch?v=nLYnDQDBrHE -- Reading Data from a File into an Array
    https://www.youtube.com/watch?v=rjxnWmYoAuI -- Passing Arrays as Function Parameters - Part 1
    https://www.youtube.com/watch?v=B4-GzUyL35g -- Passing Arrays as Function Parameters - Part 2
    https://www.youtube.com/watch?v=sLlMCsihaHQ -- Passing Arrays as Function Parameters - Constant Parameters
    https://www.youtube.com/watch?v=KFZ2Oiv5hJI -- Sorting Parallel Arrays
    https://www.youtube.com/watch?v=6zFyjzTwJZM -- Searching Parallel Arrays
    https://www.youtube.com/watch?v=QVjnwNs8UsI -- Constant Member Functions
    https://www.youtube.com/watch?v=o6n5bZ42X28 -- Passing Objects as Parameters -Reference and Const Reference
    https://www.youtube.com/watch?v=xLfbCeyxOp4 -- Static Member Variables
    https://www.youtube.com/watch?v=C6ITDGiVAtE -- Memberwise Assignment*
    https://www.youtube.com/watch?v=J9hB4kD2nLA -- Intro to Overloading Operators
    https://www.youtube.com/watch?v=d0QXTZHPsG8 -- Overloading Mathematical Operators
    https://www.youtube.com/watch?v=xHbwmFITwks -- Constant Reference Parameters and Operator Overloading
    https://www.youtube.com/watch?v=d0QXTZHPsG8 -- Overloading Mathematical Operators
    https://www.youtube.com/watch?v=xHbwmFITwks -- Constant Reference Parameters and Operator Overloading
    https://www.youtube.com/watch?v=2Kgr4ocbcQo -- Overloading Stream Insertion (Output) Operator
    https://www.youtube.com/watch?v=pZ47S85RUv4 -- Overloading the Stream Extraction (Input) Operator

C++ The Cherno (code prefix tc)
    https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb -- Playlist for C++ Programming Tutorials
    01 https://www.youtube.com/watch?v=18c3MTX0PK0 -- Welcome to C++ 7:04
    02 https://www.youtube.com/watch?v=1OsGXuNA5cc -- How to Setup C++ on Windows 8:35
    03 https://www.youtube.com/watch?v=1E_kBSka_ec -- How to Setup C++ on Mac
    04 https://www.youtube.com/watch?v=LKLuvoY6U0I -- Hot to Setup C++ on Linux 8:11
    05 https://www.youtube.com/watch?v=SfGuIVzE_Os -- How C++ Works 20:20
    06 https://www.youtube.com/watch?v=3tIqpEmWMLI -- How the C++ Compiler Works 17:54
    07 https://www.youtube.com/watch?v=H4s55GgAg0I -- How the C++ Linker Works 15:51
    08 https://www.youtube.com/watch?v=zB9RI8_wExo -- Variables in C++  13:45
    09 https://www.youtube.com/watch?v=V9zuox47zr0 -- Functions in C++ 9:49
    10 https://www.youtube.com/watch?v=9RJTQmK0YPI -- C++ Header Files 15:09
    11 https://www.youtube.com/watch?v=0ebzPwixrJA -- How to DEBUG C++ in Visual Studio 19:19
    12 https://www.youtube.com/watch?v=qEgCT87KOfc -- Conditions and Branches in C++ 24:32
    13 https://www.youtube.com/watch?v=qeH9Xv_90KM -- Best Visual Studio Setup for C++ Projects 12:07
    14 https://www.youtube.com/watch?v=_1AwR-un4Hk -- Loops in C++ (for loops, while loops) 12:19
    15 https://www.youtube.com/watch?v=a3IZ8WaIFAA -- Control Flow in C++ (continue, break, return) 8:19
    16 https://www.youtube.com/watch?v=DTxHyVn0ODg -- Pointers in C++ 16:58
    17 https://www.youtube.com/watch?v=IzoFn3dfsPA -- References in C++ 16:58
    18 https://www.youtube.com/watch?v=2BP8NhxjrO0 -- Classes in C++ 8:41
    19 https://www.youtube.com/watch?v=fLgTtaqqJp0 -- Classes vs Structs in C++ 8:31
    20 https://www.youtube.com/watch?v=3dHBFBw13E0 -- How to Write a C++ Class 11:31
    21 https://www.youtube.com/watch?v=f3FVU-iwNuA -- Static in C++ 6:28
    22 https://www.youtube.com/watch?v=V-BFlMrBtqQ -- Static for Classes and Structs in C++ 9:11
    23 https://www.youtube.com/watch?v=x55jfOd5PEE -- ENUMS in C++ 7:44
    24 https://www.youtube.com/watch?v=FXhALMsHwEY -- Constructors in C++ 6:57
    25 https://www.youtube.com/watch?v=D8cWquReFqw -- Destructors in C++ 4:46
    26 https://www.youtube.com/watch?v=X8nYM8wdNRE -- Inheritance in C++ 7:59
    27 https://www.youtube.com/watch?v=oIV2KchSyGQ -- Virtual Functions in C++ 6:45
    28 https://www.youtube.com/watch?v=UWAdd13EfM8 -- Interfaces in C++ (Pure Virtual Functions) 6:54
    29 https://www.youtube.com/watch?v=6OVQ8nh3KP0 -- Visibility in C++ 8:48
    30 https://www.youtube.com/watch?v=ENDaJi08jCU -- Arrays in C++ 18:30
    31 https://www.youtube.com/watch?v=ijIxcB9qjaU -- How Strings Work in C++ (and how to use them) 19:25
    32 https://www.youtube.com/watch?v=FeHZHF0f2dw -- String Literals in C++ 14:06
    33 https://www.youtube.com/watch?v=4fJBrditnJU -- CONST in C++ 12:53
    34 https://www.youtube.com/watch?v=bP9z3H3cVMY -- The Mutable Keyword in C++ 6:55
    35 https://www.youtube.com/watch?v=1nfuYMXjZsA -- Member Initializer Lists in C++ (Constructor Initializer List) 8:36
    36 https://www.youtube.com/watch?v=ezqsL-st8qg -- Ternary Operators in C++ (Conditional Assignment) 8:01
    37 https://www.youtube.com/watch?v=Ks97R1knQDY -- How to CREATE/INSTANTIATE OBJECTS in C++ 13:02
    38 https://www.youtube.com/watch?v=NUZdUSqsCs4 -- The NEW Keyword in C++
    39 https://www.youtube.com/watch?v=Rr1NX1lH3oE -- Implicit Conversion and the Explicit Keyword in C++
    40 https://www.youtube.com/watch?v=mS9755gF66w -- OPERATORS and OPERATOR OVERLOADING in C++
    41 https://www.youtube.com/watch?v=Z_hPJ_EhceI -- The "this" keyword in C++
    42 https://www.youtube.com/watch?v=iNuTwvD6ciI -- Object Lifetime in C++ (Stack/Scope Lifetimes)
    43 https://www.youtube.com/watch?v=UOB7-B2MfwA -- SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)
    44 https://www.youtube.com/watch?v=BvR1Pgzzr38 -- Copying and Copy Constructors in C++
    45 https://www.youtube.com/watch?v=4p3grlSpWYA -- https://www.youtube.com/watch?v=4p3grlSpWYA
    46 https://www.youtube.com/watch?v=PocJ5jXv8No -- Dynamic Arrays in C++ (std::vector)
    47 https://www.youtube.com/watch?v=HcESuwmlHEY -- Optimizing the usage of std::vector in C++
    48 https://www.youtube.com/watch?v=f7mtWD9GdJ4 -- Local Static in C++
    49 https://www.youtube.com/watch?v=or1dAmUO8k0 -- Using Libraries in C++ (Static Linking)
    50 https://www.youtube.com/watch?v=pLy69V2F_8M -- Using Dynamic Libraries in C++
    53 https://www.youtube.com/watch?v=I-hZkUa9mIs -- Templates in C++ 17:57
    54 https://www.youtube.com/watch?v=wJ1L2nSIV1s -- Stack vs Heap Memory in C++
    55 https://www.youtube.com/watch?v=j3mYki1SrKE -- Macros in C++
    56 https://www.youtube.com/watch?v=2vOPEuiGXVo -- The "auto" keyword in C++
    60 https://www.youtube.com/watch?v=4NYC-VU-svE -- Why I don't "using namespace std" 14:34
    82 https://www.youtube.com/watch?v=PPup1yeU45I -- Singletons in C++
    92 https://www.youtube.com/watch?v=ryRf4Jh_YC0 -- VECTOR/DYNAMIC ARRAY - Making DATA STRUCTURES in C++
    93 https://www.youtube.com/watch?v=SgcHcbQ0RCQ -- Iterators in C++
    95 https://www.youtube.com/watch?v=_zQqN5OYCCM -- How to REALLY learn C++ 8:12
    99 https://www.youtube.com/watch?v=vWXrFetSH8w -- Best Way to make Desktop Applications in C++
    100 https://www.youtube.com/watch?v=ceakpNctcZs -- Do REAL PROGRAMMERS use Stack Overflow or Google? (VLOG) 7:40

OpenGL, Cherno (code prefix dc)
    https://www.youtube.com/playlist?list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2 -- playlist
    https://www.youtube.com/watch?v=W3gAzLwfIP0 -- Welcome to OpenGL
    https://www.youtube.com/watch?v=OR4fNpBjmq8 -- Setting up OpenGL and Creating a Window in C++

Portfolio Courses -- C++ Tutorials
    https://www.youtube.com/playlist?list=PLA1FTfKBAEX6BdpNaWp2uw-YspHwY7qwW -- Playlist
    https://www.youtube.com/watch?v=qWPlRubVQ38 -- How To Setup A C++ Programming Environment On Windows With Visual Studio | C++ Tutorial
    https://www.youtube.com/watch?v=DRCfF4j-rGg --Hello World Program | C++ Programming Tutorial 
    https://www.youtube.com/watch?v=JJC1Ws0GXAs -- Console Output With cout Basics | C++ Tutorial
    https://www.youtube.com/watch?v=hKqNb3Wo6z0 -- User Input With cin Basics | C++ Tutorial
    https://www.youtube.com/watch?v=dKErkyRxPyE -- Comments | C++ Tutorial
    https://www.youtube.com/watch?v=zS651dNfa6c -- If Statements | C++ Tutorial
    https://www.youtube.com/watch?v=DVEo4jZsKe4 -- While Loops | C++ Tutorial
    https://www.youtube.com/watch?v=-5xVrsBguHg -- Basics Of Using The string Type | C++ Tutorial 13:59
    https://www.youtube.com/watch?v=W1CjYKmTB-c -- Introduction To Classes And Objects | C++ Tutorial 11:48
    https://www.youtube.com/watch?v=pnhGOznp0UM -- Public And Private Access Specifiers | C++ Tutorial
    https://www.youtube.com/watch?v=1oOWq4rpXIg -- Class Member Functions (aka Methods) | C++ Tutorial 7:17
    https://www.youtube.com/watch?v=bnyveJ17lao -- Constructor Basics | C++ Tutorial 7:07
    https://www.youtube.com/watch?v=abOMO8GY6io -- Destructor Basics | C++ Tutorial 9:12
    https://www.youtube.com/watch?v=Rfe2Jb2JP-Y -- Using ofstream To Write To Files | C++ Tutorial
    https://www.youtube.com/watch?v=wVhCnzFwxt4 -- How To Use ifstream To Read Files | C++ Tutorial
    https://www.youtube.com/watch?v=SgxadsKvk_A -- Class Variables (i.e. "Static Member Variables") | C++ Tutorial
    https://www.youtube.com/watch?v=1xY0rF399j0 -- Static Member Functions | C++ Tutorial
    https://www.youtube.com/watch?v=ENnnAjZcuo0 -- Declare And Initialize An Array Of Objects | C++ Tutorial
    https://www.youtube.com/watch?v=rHXPFxaOIfo -- Constructor Delegation | C++ Tutorial
    https://www.youtube.com/watch?v=cxysUPZH65Y -- Pass By Reference | C++ Tutorial
    https://www.youtube.com/watch?v=SJy4_Ci80No -- Object Assignment | C++ Tutorial
    https://www.youtube.com/watch?v=Ldv5i14UhTA -- Define A Copy Constructor To Create A Deep Copy Of An Object | C++ Tutorial
    https://www.youtube.com/watch?v=A9COxBajDng -- Function Overloading | C++ Tutorial


Colorado State CS253: Software Development with C++
    https://www.cs.colostate.edu/~cs253/Spring19/

Programming with C++
    https://www.youtube.com/watch?v=4lqY8wuZ-PU&list=PL6oj8ZA5xT3AHLqp9Xoq64xwV3IRs_TIP -- Playlist

Stanford C++ CS106B Programming Abstractions
    https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1132/

This Pointer Programming Tutorials (includes C++)
    https://thispointer.com/

C++ Algorithm Exercises
    https://www.techiedelight.com/

C++ Code Palace 18 Part Series
    https://www.youtube.com/playlist?list=PL4KX3oEgJcff8LV7P78Z7zdwMPBVDZixL -- Full C++ Tutorial

C++ Game Programming (COMP4300), Dave Churchill (code prefix dc)
    https://www.youtube.com/playlist?list=PL_xRyXins848nDj2v-TJYahzvs-XW9sVV -- Playlist
    https://www.youtube.com/watch?v=S7lXSihz0ac -- COMP4300 - C++ Game Programming - Lecture 01 - Course Introduction 01:24:45
    https://www.youtube.com/watch?v=P_mgIDWpbms -- COMP4300 - C++ Game Programming - Lecture 02 - Intro to C++ (1/2) 2:17:05
    https://www.youtube.com/watch?v=aZFXWVqgGBI -- COMP4300 - C++ Game Programming - Lecture 03 - Intro to C++ (2/2) 1:53:30
    https://www.youtube.com/watch?v=UARdwTLUH5U -- COMP4300 - Game Programming - Lecture 04 - Assignment 1 + SFML 2:00:40
    https://www.youtube.com/watch?v=9LNgSDP1zrw -- COMP4300 - Game Programming - Lecture 05 - Intro to ECS
    https://www.youtube.com/watch?v=pTWss1lY6rg -- COMP4300 - Game Programming - Lecture 06 - EntityManager + 2D Game Math

Game Programming Tutorial for Beginners in C++ (Windows), Dan Zaidan (code prefix dz)
    https://www.youtube.com/playlist?list=PL7Ej6SUky135IAAR3PFCFyiVwanauRqj3 -- Playlist
    https://www.youtube.com/watch?v=luuyjjOxnUI -- How to program a game in C++: #0 - Introduction and Setup
    https://www.youtube.com/watch?v=yD0WzbKJcOg -- How to program a game in C++: #1 - Window and Pointers
    https://www.youtube.com/watch?v=PJmpOhk9GXw -- How to program a game in C++: #2 - Drawing Graphics
    https://www.youtube.com/watch?v=gFBToWRjDZ4 -- How to program a game in C++: #3 - Input, Movement and Time
    https://www.youtube.com/watch?v=qjhbRzmBvFk -- How to program a game in C++: #4 - Gameplay, Collision, Better Movement
    https://www.youtube.com/watch?v=dDiJpGIDR_U -- How to program a game in C++: #5 - Enemy AI, Score System, Finishing the Gameplay
    https://www.youtube.com/watch?v=NiuFhNYSYyw -- How to program a game in C++: #6 - FINISHING the GAME! (Menu, Final Polish)

Making a Retro Video Game in C, Ryan Ries
    https://www.youtube.com/playlist?list=PLlaINRtydtNWuRfd4Ra3KeD6L9FP_tDE7 -- Playlist

Acronyms
    ECS -- Entities, Components and Systems
    RAII -- Resource Acquisition Is Initialization
    SFML -- Simle and Fast Multimedia Library (uses OpenGL)
    STL  -- Standard Template Library

Definitinos
    Abstract Classes: classes with virtual functions
    Access Specifiers: public:, private:, protected: -- privacy specifiers in class definitions
    Class -- user-defined type
    Member Variables -- variables defined within a class (aka attributes)
    Methods -- member functions defined within a class
    Object -- instance of a class
    String Literal -- a quoted series of characters
    Virtual Functions: functions declared in classes and prefixed virtual. Overridden in derived classes for polymorphism

Integrated Development Environments
    Visual Studio Code
    Visual Studio 2022
    C++ Builder -- https://www.embarcadero.com/products/cbuilder
    Code::Blocks
    CLion (JetBrains)
    Eclipse
    CodeLite
    Sublime Text
    NetBeans
    Brackets
    QT Creator
    Atom
    Dev C++
    Ajunta on Linux
    http://www.bloodshed.net/dev/devcpp.html

Background
    Compiled language
    Emphasizes speed and functionality
    Mid-level programming language
    Widely used in gaming
    Multiple Libraries
    Code is fast
    Common syntax
    Not garbage collected
    Statically typed

Exercises
    Codewars
    CodinGame
    Competitive programming
    DevSkiller
    HackerRank
    https://practity.com/
    https://www.w3resource.com/cpp-exercises/basic/index.php
    https://techstudy.org/CplusplusLanguage/cpp-programming-example-and-solutions/
    https://edabit.com/challenges/cpp#!
    https://www.cs.purdue.edu/homes/bxd/CandC++/

Warnings and Tips and Tricks and Practices
    Mark variable and function definitions static to avoid global scope
    Put #pragma once in header files to avoid duplication of headers and #IFDEF statement
    Use std::cin.get() to pause execution of a program which is the same as system("pause") in windows but works for all operating systems
    Always prefix the std:: namespace on standard library functions
    Never put "using namespace <>" in header files or code files
    Use std::cin.ignore() then std::getline(cin, strInput) to get a string of console input with embedded spaces
    use std::to_string(<int>) to convert an integer to a string 

Compilers (installed on /usr/bin)
    CLang llvm
    Msvc -- Microsoft compiler included in Microsoft Visual Studio
    gcc and G++

Compilers installed on Windows
    Visual studio
    mingw

Visual Studio Shortcuts
    Set Visual Studio configuration options -- Tools Get Tools and reatures
    Open a project -- File > Open > Project and open the .sln file
    Dark Mode -- Menu > Tools > Options > Environment > General > Color Theme > Dark
    Compilation Options -- Solution Explorer
    Solution Explorer -- Menu > View > Solution Explorer (or <ctrl><alt> l
    compile current source without linking -- <ctrl><f7>
    compile and link and execute with debugging -- <f5>, or Debug > Start debugging
    compile and link and execute without debugging -- <ctrl><f5>, or Debug > Start without debugging
    Properties -- <alt><enter>
    Generate translation unit (.i) -- <alt><enter> > C/C++ > Preprocessor > Preprocess to a file
    Generate assembly file (.asm> --  <alt><enter> > C/C++ > Output Files > Assembler Output > Assembly Only Listing (/FA)
    Set breakpoint on cursorline -- <f9>
    Step into (debug) -- <f11>
    Step over (debug) -- <f10>
    Step out (debug) -- <shft><f11>
    Run to current line -- <Ctrl><F10>
    Continue -- <f5>
    Stack Memory -- Debug > Window > Memory > or <ctrl><alt>m ...
    New Project -- File > New > Project > 
    Change startup entry point to a different project -- Project > Set as Startup Project
    Watch Window (in debug) -- Debug > Windows > Watch or <Ctrl><Alt>W then a number

Compilers (online)
    Wandbox https://wandbox.org
    Compiler Explorer https://www.godbolt.org/
    Coliru http://coliru.stacked-crooked.com/
    http://cpp.sh/ -- C++ compilation environment for http:://cplusplus.com/
        CodinGame
    Competitive programming
    DevSkiller
    HackerRank
    https://cppinsights.io/

LibC Library Built-ins

Third Party Libraries
    Boost C++
    Dear ImGui
    Direct3D -- graphics API for Windows
    https://www.wxwidgets.org -- GUI
    Open GL -- graphics specification API (implemented by GPU manufacturers)
    Qt -- GUI
    SMFL -- Simle and Fast Multimedia Library, a graphics library written in C++
    Vulcan -- graphics library

Compilation and Linking Steps
    Preprocess each source file (replaces include lines) and creates translation units
    Compile each translation unit to create object files (one for each translation unit)
        Abstact syntax tree
        Code generation into object files (one for each cpp file)
    Link all object files together --> a.out (default) and define the entry point from main()
    Since one c source file can include another c source file, the result is called a translation unit
    The compiler takes translation units as input and not files
    If there are no c files included in other c files, each c file becomes a translation unit after .h includes are processed

Compilation Options
     g++ -g -o <progName> <progName>.cpp
         -o name of output file
         -g enable debug symbols
         -E view preprocessor results
     g++-11 -g -o <progName> <progName>.cpp -- latest version of gcc/g++ on linux
         -Wall all warnings
         -Weffc++
         -Wextra -- extra warnings
         -Wpedantic -- trivial warnings
         -Wsign-conversion
         -I/source/includes -- alternate path for local header files

compilation Examples
    g++ -std=c++17 lecture2.cpp -o lecture2

Compiler Optimizations and Optimization Levels

Preprocessor Directives and Preprocessor Statements
    # -- identifies a preprocessor statement
		# include <iostream> substitutes everything in the iostream file into the source (header files)
    macros are substitution text
    Macros can be multiline if the '\' line continuation is used
    #pragma once -- only includes the contents of an include file once in single translation unit
    #ifndef _SYMBL ... #define SYMBL ... #endif will only include function prototypes once (interchangeable with #pragma once)
    #define -- defines a translation for fixed text that is substituted in the source

Preprocessor Macro Symbols for Debugging
    __LINE__  line number integer
    __FILE__  source file name string
    __func__  function name string
    __DATE__  date string
    __TIME__  time string

Naming Standards
    .cpp -- source code extension -- function and class definitions
    .h -- header files -- function and class declarations

Header Files (Include Files)
    Commonplace to store class and function declarations (not definitions) in header files
    C++ header files do not have a file extension
    Declarations must be made before classes and functions are used
    However, any file can be an include file (including other .cpp files). Including is a mechanical process
    Common Includes into source cpp files
    <> means the include file is in one of the standard include directories (/usr/include/c++/9)
    <iostream> -- iostreams library
    <limits> uses std::numeric_limits<std::streamsize>::max()
    <cctype.h>
    <sstream> -- string streams
    <cstdio> -- standard C I/O functions

Code Formatters (Linux)
    astyle <program.cpp> - formats cpp and backs up original to <program.cpp.orig>

Namespaces
    A namespace is a region that allows declaration of names for disambiguation
    A namespace defines a scope of unique names for functions or variables (identifiers)
    std -- all standard library tpes and functions are declared in the std namespace
    Within a namespace all identifiers are unique
    Duplicate names for functions and variables (identifiers) are naming collisions (namespace collisions) and not allowed within a single namespace
    Qualified names are names with associated scope
    Qualified names have a namespace and scope resolution operator ::
    std -- the standard namespace for the standard library: clib
    using namespace std; -- is a compiler instruction to import all names from STD into the current scope
    using namespace std; -- can be placed inside a code block to limit its scope
    Limit using namespace <namespace> within code and avoid putting in the global area or header files
    use namespace qualifiers instead of using namespace <namespace> to avoid collisions
    limit 'using' to actual names: using std::string, using std::cout etc
    Identifiers declared outside a namespace are global
    All identifier names in the C++ standard library are within the std namespace
    Define a namespace with the namespace keyword e.g. namespace foo { .. } at the beginning of a block
    The same namespace can be used in multiple files and all member form part of the same namespace
    Namespaces can be nested and the corresponding scope resolution is nested
    Namespaces can be aliased e.g. namespace new = old;

Scope
    An entity declared outside any block has global scope
    An entity declared within a block has scope limited to the block and its inner blocks (block scope)
    An entity name can be reused within an inner block and the inner block entity will have prcedence within its block scope
    Variables with block scope are local variables
    There cannot be two entities with the same name in the same scope
    Multiple inner blocks can be declared with {...} without any other construct (such as while(){...} or for(){...}

Stream Input (CIN)
    std::cin -- stdin file identifier or stream object (character input) - read character data from the console if they match the input type
    std::cin >> extraction operator
    std::cin.fail() -- returns true if input is invalid and must be cleared
    std::cin.clear() -- clear the error state of the buffer after invalid input (reset value of std::cin.fail())
    std::cin.eof() -- returns true if reading from cin is end-of-file (i.e no input)
    std::cin.ignore() -- ignore the next character (whitespace) in CIN after getline() or cin
    std::cin.ignore(1000,'\n')  -- clear the input buffer
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); #include <limits> -- flushes the cin buffer up to '\n'
    std::cin >> std:ws -- output manipulator to ignore whitespace (e.g. std:getline(std:cin >> std::ws, myString) clears leading whitespace)
    std::cin.sync(); -- clear the input buffer
    std::getline(std::cin, <variableName>); - get a line of text with embedded whitespace but leaves trailing whitespace and newline
    std::getline(std::cin, <variableName> <delim>); - get a line of text with embedded whitespace and newlines up to the delimiter
    std::cin.getline(char myArray[count], int <count>) reads input up to int characters into an array of char myArray[int]\n' and stops
    std::cin.get() reads input up to '\n' and keeps '\n' in the stream

Stream Output (cout)
    std::cout -- stdout file identifier or stream object (character output) - print character data to the console
    std::cout << insertion operator
    std::cout << u8"\033[2J\033[1;1H"; -- clear the console in linux using #include <iomanip> (or system("clear");
    std::cerr -- stderr file identifer or stream object (character error) , print character errors to the console and unbuffered
    std::clog -- stdlog file identifier or stream object (character log), print character log messages to the console, buffered
    std::endl -- endline or newline '\n'. endl flushes the output buffer. Do << '\n' to avoid the cost of a buffer flush (for example, in a for loop printing multiple lines
    std::setprecision(20) -- sets the maximum precision (include <iomanip>)
    std::width(10) -- sets the field width to 10 (include <iomanip>)
    std::boolalpha -- prints boolean values as words
    std::istringstream -- string buffer to process strings line-by-line (include <sstream>)

Stream Output (COUTFormatting
    #include <iomanip>
    std::fixed -- suppress exponential format and use fixed decimals
    std::showpoint -- show decimal points on whole numbers
    std::setprecision(2)
    std::setw(n) -- set integer format to n characters (not persistant) right aligned
    std::left -- align text left, numbers right (persistant)
    std::right -- align text right, numbers left (persistant)
    std::setfill('.') -- use a fill character on text output
    std::boolalpha -- print boolean values as alpha values: 'true' or 'false'
    std::oct -- print octal value
    std::dec -- print decimal value
    std::hex -- print hex value

File Streams
    #include <fstream> -- covers ofstream and ifstream
    ofstream outFile -- output to files or write
    ifstream in File -- input from files or read
    outFile.open("myfile.txt", mode) -- default mode is overwrite/truncate existing
    inFile.open("myfile.txt", mode) -- default mode is overwrite/truncate existing
    File modes:
        std::ios_base::app -- seek to the end of stream before each writing
        std::ios_base::binary -- open in binary mode
        std::ios_base::in -- open for reading
        std::ios_base::out -- open for writing and not appending
        std::ios_base::trunc -- discard the contents of the stream when opening
        std::ios_base::ate -- seek to the end of stream immediately after open
    infile.eof() tests for end of file reading

Updating Repositories in Ubuntu using APT (Advanced Packaging Tool)

Debugging with GDB

Debugging CGI with GDB

Coredump(in Linux)

Linker and Assembler

GCC Command Options

Compilation Process
    C++ programs are compiled into binaries
    There is no virtual machine or interpreter
    Steps
        Write Source Code
        Preprocessing -- runs preprocess directives to combine header files -> Expanded Source Code
            includes libraries
            includes headers
            resovles macros
            g++ -E myprogr.cpp > myprog.s (expanded preprocessed source file)
        Compiling -- check syntax and create object file -> Object file (.o)
            g++ -c myprog.c generates an object file
        Linking -- creates executable file
            g++ -o myprog myprog1.c myprog2.o

Compilation Toolchain (Process)

Compilation of Multiple Files

Make
    Make works in C++
    configures the compilation process

Memory Model
    Stack Memory (aka static memory)
        allocated when variables are declared (without the new keyword)
        automatically deallocated when out of scope
        stack allocation is fast for new variable creation
        stack memory grows downwards
        an example: 0x7ffc62544cc0 0x 7ffc 6254 4cc0 which is 48 bits long (not 64 bits)
            the most significant 16 bits are not needed or used but are stored in a 64 bit register
    Heap Memory (aka dynamic memory)
        allocated with the new keyword
        has a predefined size (several megabytes)
        pointers are used to access heap variables
        pointers must be deleted to deallocate their heap memory
        heap allocation is slow for new variables
        heap memory grows upwards

Format Specifiers

Special Format Characters (Escape Sequences)
    \a -- alert or beep
    \b -- backspace
    \f -- formfeed
    \n -- newline
    \r -- carriage return
    \v -- vertical tab
    \' -- single quote
    \" -- double quotes
    \\ -- backslash
    \? -- question mark
    \(number) -- character represented by octal (number)
    \x(number) -- character represented by hex (number)

IDE Tools
    http://www.bloodshed.net/dev/devcpp.html - Dev-Cpp installable IDE for C/C++
    http://www.codeblocks.org/downloads/26 -- Code Blocks installable IDE for C/C++
    https://www.eclipse.org/cdt/ -- Eclipse C/C++ Development Tooling
    https://netbeans.org/features/cpp/ -- Netbeans C/C++ Development
    https://codelite.org/ -- Codelite IDE for C++, C, Rust, Node and php

Tools
    HxD -- binary editor at https://mh-nexus.de/en/hxd/

C++ Language Rules

Comments
    Single line or partial line comments start with //
    Multiline or block comments are bounded by /* and */

Datatypes (aka Primitives)
    Different primitives required different memory sizes
    sizeof(<type>) returns the size in size_t of a datatype
    Integral Types (stored as integers)g
        character
            char -- characters (1 byte, 256 values)a -- characters are just numbers
            char16_t -- 2 bytes, 65,536 values
            char32_t -- 4 bytes, 4,294,967,296 values)
            wchar_t -- 2 byte -- a wide character
        integer (signed or unsiged)
            short -- short integer (2 bytes)
            int -- signed integers (4 bytes), signed, -2bill - 2bill
            unsigned int -- positive Integers (4 bytes) 0 - 4bill
            long -- long integer (4 bytes)
            unsigned long -- (4 bytes)
            long long -- long long integer (8 bytes)
            unsigned long long (8 bytes)
        float
            float -- floating point numbers (4 bytes) and precision 7-- append f ir F to the number otherwise it will default to a double
            double -- double precsion floating point numbers (8 byte) and precision 15
            long double -- long double precision floating point numbers (8 bytes)
        boolean
            bool -- booleans (1 byte) (false = 0, true != 0)
    Non-integral Types
        void
            void -- no type
        null pointer
            decltype(nullptr)
    auto -- a compile keyword diecting the compiler to derive the type

Datatype Initialization
    int val{3}; sets val to 3
    int val = 3 sets val to 3 also

Static and Extern Keyword
    Outside of a class or struct, static declares a variable or function as local to a translation unit
    Extern declares a variable as defined elsewhere (in another translation unit)
    Inside a class or struct, static declares a variable or function as shared across all instances of a class
    Static methods cannot access non-static variables in a class
    Static methods which are class level cannot reference non-static variables which are object level
    Variables and functions should be static to avoid global scope (unless global scope is needed)

Compound Data Types
    std::string -- variable-length string operators #include <string>

Literal Suffixes
    If the default type of a literal constant is not wanted, you can change it with a literal suffix
        u or U -- unsigned integer
        l or L -- long
        ul, uL, Ul, UL, lu lU, Lu or LU -- unsigned long
        ull, uLL, Ull, ULL, LLu llU, or LLU =- unsigned long long
        f or F -- float
        l or L -- long double

Other Type Declarations
    size_t -- unsigned integer type returned by sizof()
    bool -- booleans true or false
    void --
    auto -- let the compiler determine the data type based on the context of the declaration

Enumerations or Enums
    Enumerations are nameed sets of named integers
    Enumerator types represent integers as pseudonym words
    enum <myEnum> {<word1>, <word2>, <word3>, ...<wordn>};
    Variables can be typed as enums: <myEnum> Var1 = <wordn>;
    Each enumeration type value is processed as an integer (e.g. for input and output)

Type Conversion
    Implicit type conversions are automatic
        Safe implicit conversion: int to double
        Unsafe implicit conversion: double to int (loss of fractional part)
    Explict type conversions are coded into source programs
        static_cast<new type>(expression) e.g. static_cast<int>(expression)
        static_cast behaviour is undefined if the value converted is not in the range of the new type

Identifiers, Variables and Naming Conventions
    Identifiers name variables, functions and other items
    Identifiers cannot be keywords (see list below)
    Identifiers can comprise letters (upper or lower case), numbers or underscore
    Identifiers starting with "_" are compiler-specific or external (by convention)
    Identifiers are case-sensitive

Keywords
    alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool, break, case, catch, char, char16_t, char32_t, 
    class, compl, const, constexpr, const_cast, continue, decltype, default, delete, do, double, dynamic_cast, 
    else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutable, 
    namespace, new, noexcept, not, not_eq, nullptr, operator, or, or_eq, private, protected, public, register, 
    reinterpret_cast, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, 
    this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, 
    volatile, wchar_t, while, xor, xor_eq

Boolean Initialization
    bool b1 {true};
    bool b2 {!true};
    bool b3 {false};
    bool b4 {!false};
    bool b5 {}; defaults to false
    bool b6 = true;
    bool b7 = false;

Integer Initialization
    Assignment initialization -- int x = 3, assigns 3 to x
    Braced int a{9}; -- direct brace initialization or constructor initialization
    int b{}; -- defaults the initialization to 0
    Braced int a = {9}; copy brace (or list or uniform) initialization
    Functional variable initialization: int val1(2) sets val2 to 2
    Default int a{}; sets a to zero;
    Functional int a(9) -- direct initialization
    Assignment int a = 9; -- copy initialization or c-like initialization
    auto initialization -- let the compiler derive the type as the type of it's initial value -- good for shortening long types
    decltype (intA1) intA2; // initializes intA2 to be the same type as intA2
    int *ptrInt1{new int}; -- allocates integer on the heap
    int *ptrInt2(new int{22}} -- allocates and initializes an integer on the heap
    int *ptrInt3(new int(33)} -- allocates and initializes an integer 33 on the heap

Integer Modifiers
    signed
    unsigned
    short
    long
    long long

Integer Modifiers
    signed, range -2**(n-1) .. 2**(n-1) - 1
    unsigned, range  2**n - 1
    short 2 bytes
    long 4 or 8 bytes
    long long 8 bytes
    mutable -- makes a variable changeable within a const function
    const -- variable value that cannot be changed
        const int* myPtr= new int; makes the contents of myPtr constant and not the address myPtr
        int * const myPtr = new int; makes the address myPtr constant and not the contents

Character Initialization
    char c1 {'a'}; -- braced init-list
    char c2 = 65 // same as 'A'

Floating Point Modifiers
    float has precision 7
    double has precision 15
    long double has precision 15

Floating Point Initialization
    Braced num1 {1.924e8}
    Braced num2 (1.849e-4}

Numeric Systems
    binary prefix 0b eg. 0b00001111 is 15 decimal
    octal prefix  0  eg. 017 is 15 decimal
    hex prefix    0x eg. 0x0f or 0x0F is 15 decimal

Standard Template Library (STL)
    Collections of container types e.g. arrays, lists, queues, stacks, trees
    Algorithms that work on containers
    Iterators for containers

Arrays (Raw)
    An array is a collection of variables or elements manipulated as a single variable
    Array names are pointer types
    int scores[10]; -- declare an array of 10 integers on the stack
    int *scores = new int[10]; -- create an array on the heap for 10 integers
    delete [] scores; -- delete an array from the heap
    int moreInts[] {1, 2, 3, 4, 5} -- creates a 5 element array of integers using a braced init-list
    int theseVals[10] {1, 2, 3} -- zero fills the uninitialized elements
    char chrVals[10] {1, 2, 3} -- the compiler fills NULL  to the remaining uninitialized elements
    char myArray[] {"Hello World!"} -- uses brace-intitalized string which will be '\0' terminated automatically
    int thisArray[]; -- compiler error, size cannot be determined
    std::size(myArray) -- gives the number of elements in a stack array (C++17) but not on a pointer
    sizeof(myArray)/sizeof(myArray[0]) -- gives the number of elements in the array on the stack
    Iterate through an array with a range-based for loop: for (auto iterator : myArray) {std::cout << iterator << std:endl;}
    Range-based for loops or 'range for loops' work on arrays but not on pointers
    Static arrays live in the stack
    Dynamic arrays live on the heap

Arrays (Standard Template Library)
    Standard arrays are defined in the standard template library starting in C++ 11
    Requires #include <array> header file
    std::array<int, 5> array1;
    array1.size -- size of the standard array

Character Functions(include <cctype>)
    std::isalnum() returns non-zero if a character is alphanumeric (a letter or a number)
    std::isalpha() returns non-zero if a characer is alphabetic (a-zA-Z)
    std::islower() returns non-zero if a character is lowercase
    std::isupper() returns non-zero if a character is uppercase
    std::isdigit() returns non-zero if a character is a digit
    std::tolower() converts a character to lowercase
    std::toupper() converts a character to uppercase
    std::isblank() returns non-zero if a character is a blank space

Strings <string>
    const char *myString = "This is a string"; -- cannot be changed because it is 'const'
    std::string myString1 = "This is another string";
    myString.size() -- gives the string size including the teminating NULL value
    myString.at(1) gives 'h' -- same as myString[1]
    strings are null-terminated ('\0') character arrays (aka c-strings);
    String literals are expressed as: "This is a string"
    Const string literals are stored in the CONST section of the compiled binary and cannot be changed (changing is undefineed behaviour)
    String initialization: const char *p_message {"Hello World!"}; -- cannot be changed
    string initialization: const char message[] = "Hello World" -- can be changed
    Initialized strings are const or immutable -- they cannot be grown in size (but their individual characters can change)
    Use char [] arrays for strings that need to be changed
    Use std::cin >> strMyString to fetch a single word from the console
    Use getline(std::cin >> std::ws, strMyString) to get a sentence from the console and ignore leading whitespace
    Concatenate using a + operator e.g. str1 = str1 + "more chars"; -- is str1 is defined as std::string str1 = "some chars";
    Concatenate using string2.append("More chars");
    Check if a string is empty -- if (str3.empty()) {}
    Clear a string with str3.clear();
    Convert a numeric value to a string -- string str4 = to_string(100.45);
    Convert a string to a number -- double number = stod(str5); where str5 = "34.23"; see also stoi, stol, stoll
    Substring with str string sub = testStr3.substr(2, 4) -- returns a substring

STL Strings (Standard Template Library or STL)
    Requires #include <string>
    A collection of classes and functions
    Examples
        Strings/IO/Streams/Files
        Generic Containers (vectgor, set, map)
        Container functionality (fill, copy, erase)
        Algorithms (sort, max/min)
    Strings are defined in the standard template library
    basic_string is the underlying template class
    #include <string> to use the std::string object
    string is a template specialization of basic_string for the char data type
    wide strings comprise 2-byte characters and they have type wchar_t -- handles unicode characters
    Strings from the STD library implement RAII

String Declarations (include <string>)
    std::string objects can change size dynamically at run time
    std::string strMyString; -- empty string
    std::string strMyString {}; -- empty string
    std::string strMyString {"this is a string"}; -- initialized string
    std::string strMyString2 = "Another string";
    std::string ("Hello there", 5}; -- initialize with the first five characters "Hello"
    std::string strMyString {"Hello there", 6,5}; -- intialize with a range of characters "there"
    std::string strMyString {4, 'x'}; gives "xxxx"

String Member Functions
    str.append("newstring") appends "newstring" to str
    str.length() gives the length of a string

String Functions <cstring> for functions and <string> for std::string classes
    std::strlen() -- calculate the length of a string (excluding the terminating null)
    std::strcmp() -- compare two strings
    std::strncmp()-- compares two strings for the first n chars
    std::strchr() -- returns a char pointer to the first occurance of a character in a string
    std::strrchr() -- returns a char pointer to the last occurance of a character in a string
    std::strcpy() -- copies a string
    std::strncpy -- copies n characters from a string
    std::strcat -- concatenates two strings
    std::strncat -- concatenates the first n characters of two strings

Whitespace
    Comprises: newlines, spaces and tabs
    C++ compiler ignores repeated whitespaces
    Line continuations on strings require ending " on the starting line and opening " on the following line
    Lint continuation on an expession does not requred any special characters ... just break the line into two lines
    Spaces within double-quoted text are honored

Indentation
    K&R Variant e.g. while (x == y) { ...
    Allman style e.g. while (x == y) 
                      { ..

Statements
    Statements terminate with a semicolon
    Statements are executed in order and follow branches

Branching and Conditional Statements
    if(a == b)
    {
        std::cout << a << "equals" << b < std::endl;
    }

Loops
    The increment variable in a for loop is incremented after the loop body is executed and not before
    for (int i = 0; i < 10; i++)
    {
        <loop body code>
    }
    while (a < b) 
    {
        <loop body code>;
    }
    do
    {
        <lpop body code>;
    } while (a < b);

Control Flow
    Continue -- skips to the next iteration of a loop, used inside loops
    Break -- break out of a loop, used inside loops
    Return -- exit a function, can be placed anywhere

Logical Operators
    ~ -- not
    a & b -- and
    a | b -- or
    a ^ b -- exclusive or
    a << b -- left shift
    a >> b -- right shift

Arithmetic Operators
    a + b -- addition
    a - b -- subtraction
    +a    -- unary plus
    -b    -- unary minus
    a * b -- multiplication
    a / b -- division
    a % b -- modulo (i.e. remainder)
    ++a   -- preincremetn
    a++   -- post increment
    --b   -- predecrement
    b--   -- postdecrement
    =     -- assignment
    ==    -- equality
    ===   -- full equality (value and type)

Class Operators
    Class operators are functions (eg. << in cout)

Pointers
    A pointer is a a memory address and an associated type
    int *p_number1{nullptr} initializes p_number1 to NULL explicitly -- nullptr was introduced in C++11
    int *p_number1{} initializes p_number1 to NULL implicitly
    int *p_number1 = nullptr initialized p_number1 to NULL explicitly
    All pointers are the same size regardless of the data type they point to
    & operator -- address of value
    * value at address (dereferencing)
    pointers are 8 bytes
    Dangling pointers: unitialized, deleted or duplicate
    void *ptr = 0; a typeless pointer pointing to NULL or a null pointer
    void *ptr = nullptr where nullptr is a #define for 0

Pointer Arithmetic

References
    A reference is an implicitly dereferenced pointer
    References are 'safe' pointers and use '&' instead of '*'
    References are aliases to variables
    References are defined as part of the variable (eg. int& var or int &var)
    References must point to existing data - the data must exist
    References must be initialized ... they cannot be declared without an assignment
    int& ref1 = 22 -- declares a reference 'ref1' to a value
    int& ref1 = a -- declares a reference 'ref1' to a varialble 'a'
    A const reference cannot be modified but the original non-const variable it refers to can be changed
    References vs Pointers
        References cannot be NULL
        You cannot change a variable that is referenced by a reference
        You cannot do math on references
        You cannot have a reference to a reference

Reference Parameters
    Pass reference parameters in functions to return additional results
    void myFunction(int &param1, int& param2) identifies parameters as references
    The reference operator '&' is in the function prototype and not the calling statement
    The return type should be void for functions taking reference parameters
    Constant reference parameters should be used in functions which do not change values of parameters (e.g. when passing object references for efficiency)

Heap Manipulation with New and Delete
    ptrNum1 = new int; -- allocate memory and return a pointer
    ptrNum1 = new int[10]; -- allocate memory for an array of 10 integers and return a pointer
    ptrObj1 = new Constructor(<var1>, <var2>) -- create a new instance of an object
    ptrobj1->method() -- calls a method within an object through it's new pointer
    int *ptrNum1 {new(std::nothrow) int[10000]}; -- do not throw an error if allocation fails -- return a nullptr instead
    delete ptrNum1 -- deletes the memory allocated to ptrNum1 (it is safe to delete a null pointer)
    delete[[ ptrNum1; -- deletes the memory allocated to ptrNum1 array
    delete should not be called more than once on a pointer
    reset a pointer to deleted memory to nullptr

Templates or Function Templates (Generics) or Parameterized Types
    There are class templates and typename templates in C++
    Avoids code repitition with function overloads (eg. same function with different parameter datatypes)
    Function templates are blueprints and not actual code ... they are transformed to code at compile time to template instance(s)
    Template prototype (by value): template <typenamei|class T> T <functionName> (T a, T b){...}; where T is a placeholder for the return type and parameter types
    Template prototype (by reference): template <typename T> T& <functionName> (T& a, T& b){...}; where T is a placeholder for the return type and parameter types
    Templates only deal with a common datatype for the return and the parameter variables
    The compiler replaces the T placeholder with the actual type when the function is called
    The value of template parameters is determined at compile time
    Template type deduction (argument deduction) deduces the type for a template based on the type of the arguments
    If the arguments have different types, explicit template arguments can be stated within <datatype>
    Explicit arguments force the template datatype to a stated value
    Template specializations are templates that override standard templates with specific types (e.g. char* values)
    The compiler replaces the T placeholder with the actual type when the function is called
    Initialize data members in the base reference initialization section for efficiency
    Templates must be defined outside of block scope (ie. not within any function)

Concepts (C++20) #include <concepts>
    A mechanism to constrain template type parameters
    Standard concepts: same_as, derived_from, common_reference_with, common_with, integral, signed_integral, unsigned_integral, floating_point
    custom concepts
    Implement with 'requires std::<concept <T>'

Classes and Structures and Objects
    Classes encapsulate data (members) and functions (methods) in a container. data and functions can be public or private
        wheras structures are public. All members are public in a struct
    Structs are normally used to define complex data collections but not methods
    Strucst exist in C++ for backward compatibility with C but they do more than C structs
    Structs in C++ can contain data and methods but they are public by default
    Declare a class e.g. class MyClass;
    Define a class e.g. class MyClass{ ... };
    Member access specifiers in classes are public:, protected: and private:
    Members are private by default in classes
    Setters and Getters are functions which set and get private member data in a class
    Inline functions are defined within a class definition and are substituted into the calling function rather than promoted on the stack
    Inline functions are typically one line such as getter functions with a single return statment
    Class functions (mehods can be defined outside of their class using the class name and scope resolution operator ... <classname>::
    Constructors initialize data in an object and are run automatically when an object is instantiated
    Constant functions do not change any data members in a class and are denoted by <functionname><parameterlist> const {<body} -- this is const correctness
    Getters are constant functions
    static members in objects are shared across all objects of a class and onl exist in one place
    Memberwise assignment assigns members of one object to members of another object

Constructors
    Constructors initialize instances of an object wheb they are created
    Constructors are public methods with the method name exactly matching the class name (e.g. <classname>();
    Constructors can be written to take parameters to set data members in their class
    Constructors initialize data in an object and are run automatically when an object is instantiated
    A default constructor is created by the compiler if no constructor is defined in the code but it does not initialize variable
    The default constructor is not generated if any other constructor is defined in the code
    A default constructor can be forced in the code with the public classmethod <ClassName>() = default;
    The default constructor can be suppressed using the 'delete' keyword e.g. myCLass() = delete
    Member initializer lists in constructors are the most efficient way to initialize values
        Entity()                                                         -- constructor function
            :m_name(name), m_age(age)                                    -- initializer list

Destructors
    Destructors clean up objects after their use
    Destructors are called autmatically when class objects pass out of scope
    Destructors begin with a ~ tilde and have the same name as the class

Inheritance
    Use the ':' character to sublcass in a class definition
        class Player : public Entity -- creates a Player class from an Entity class
    Any derived class must override all pure virtual functions of the parent or it will also be an abstract class

Virtual Functions (aka Methods)
    Virtual methods override methods in subclasses
    Methods tagged as virtual in a class can be overridden in the subclass
    Prefix the method in the base class with 'virutal'
    Suffix the over-riding function in the inherited class with 'override' to enforce syntax checking (optional)

Pure Virtual Functions
    Pure Virtual Functions are template functions in the base class that are implemented in the subclasses (same as an interface in other languages: Java, C#)
    Abstact classes are classes containing pure virtual functions

Visibility
    Private, Protected and Public are visibility modifiers for class members and methods
    Class members and methods are private by default
    Private means the methods and members can only be accessed from methods within the class
    Friends of a class can access private members
    Subclasses cannot access members or methods of their parent class
    Protected means a class and all subclassses can access protected members
    Public methods and members can be accessed by subclasses and anywhere in a program

RAII (Resource Acquisition Is Initialization)
    RAII is a programming method that wraps dynamic variables inside corresponding classes
    The destructor in the class deallocates the memory when the class object passes out of scope 

Smart Pointers and Shared Pointers
    A smart pointer is a pointer to a class that encapsulates data
    A smart pointer implements RAII
    A shared ponteris a smart pointer in the STD library that can be created more than once
    The object ponted to by the shared pointer is deleted when the its last shared pointer falls out of scope

Functions
    Functions are groups of statements executed in order
    Functions must be declared before they are used in main() via a declaration or prototype
    Functions can have the same name if the parameters are different (either in number or type)
    Overloaded functions have the same name but different parameters
    You cannot overload a function by having two different return types
    Parameter names are optional in function declarations
    Functions must be defined with a function body which can precede or follow main()
    Function bodies are between the {} curly braces
    Caller functions call other functions
    Callee functions are called by other functions
    Functions must be unique (includes function names and parameters)
    Function parameters can pass by value or by reference e.g. int a or int& a
    const keyword on reference parameters block changes to the parameters in the function
    const is used where reference parameters are needed for efficiency but changes are unwanted
    const reference parameters are efficient for compound datatypes (e.g. structs and objects) but not fundamental types
    Function definitions cannot be nested (i.e. defined within other functions)
    Functions with a return type void return no value and do not need a return statement
    void can be used in a function parameter list to indicate no parameters are taken (not required)
    Return value 0 means success
    Return value non-zero means an exception of failure
    You cannot call main() - compiler error
    C++ supports first class functions -- functions which can be treated like any other variable
    The implicit return from main() is 0 if no return statement is given
    EXIT_SUCCESS and EXIT_FAILURE are defined in <cstdlib>
    The inline keyword forces the compiler to expand the function in line with the calling code
    The C++ compiler will inline code to optimize if appropriate even if the inline qualifier is not given
    Default parameters can be specified to eliminate the need to specify them in a call (e.g. myFunc(int A, int B = 3))

Function Forward Declarations
    Functions must be defined before they are used
    Functions must be declared before they are referenced
    Forward declarations declare a function before it is referenced or defined
    Define a function before main() or include a forward declaration before main() or include via a header file
    Use a function prototype for a forward declaration
    A function prototype includes a name, return type and parameter types. Parameter names are optional but add to readability
    Function prototypes without function definitions will fail linking if the function is called
    Functions with the same name but different parameters are distinct and different functions

Function Return Values
    The default return of main() is zero
    Functions other than main() have no default return value

Function Overloading
    Overloading functions have different parameters (order, number and type) but the same function name
    Return Type is not considered in function overloading

Functions in lib.c (Standard Library) and Other Libraries

Lambda Functions
    Anonymous Functions
    Signature: [capture list] (parameters) -> return type {<function body>};
    Example: [](){std::cout << "Hello World!" << std::endl;};
    Assignment: auto func = [](){std::count << "Hello World!" << std::endl;};
    Make a lambda function callable by suffixing ()
    Capture lists allow reference to external variables without passing as parameters
    Capture lists are by value or by reference (using a leading &)
    = within the capture list captures all variables in the outer scope by value
    & within the capture list captures all variabels in the outer scope by reference

Function Pointers

Assertions

Error Handling

Exceptions (try catch blocks)
    try {
    ...
    throw (<value>>
    ...
    } catch (type <value>)
        if (<value> = value1) {
            <action1>
        } else if (<value> = value2) {
            <action2>
        }
    }

Refactoring
    Splitting functions into subfunctions or factor functions

Linters (Static Analysis Tools)
    based on lint by Stephen C Johson Bell Labs 1978
    cppcheck <progName.cpp> on a single program
    cppcheck ./*cpp on all cpp programs in the current directory

Vectors
    A vector is a variable-sized array
    .size() -- fetch the number of members in a vector
    .push_back() -- add to the end of the vector
    .erase()
    Always pass vectors into functions by reference to avoid copying

Console Colors
    ANSI Escape Sequences for colors$
    #define NC      "\e[0m"$
    #define RED     "\e[0;31m"$
    #define GRN     "\e[0;32m"$
    #define CYAN    "\e[0;33m"$
    #define BLUE    "\e[0;34m"$
    #define MAGENTA "\e[0;35m"$
    #define CYN     "\e[0;36m"$

MySQL Connector for C++
    https://www.youtube.com/watch?v=cSZvq7Kv6_0 -- database connection in C++ and mySQL
    https://www.youtube.com/watch?v=ASPQ0YarKCk -- C++ Programming on Linux - Connect to MySql database
    apt install libmysqlcppconn-dev creates /usr/include/cppconn/ ... header files
    https://askubuntu.com/questions/165868/installing-mysql-connector-c#:~:text=Goto%20command%20line%20and%20type%20%3A%20sudo%20apt-get,Download%20And%20download%20and%20build%20the%20connector%20yourself.
    https://docs.oracle.com/cd/E17952_01/connector-cpp-1.1-en/connector-cpp-getting-started-examples.html
    https://archive.ph/TeGBj
    https://stackoverflow.com/questions/16424828/how-to-connect-mysql-database-using-c
    g++-11 -I/usr/include/cppconn -o testSQL testSQL.cpp -L/usr/lib -lmysqlcppconn -- good compile line for cpp and SQL connector
    https://docs.huihoo.com/mysql/mysql-apps-using-connector-and-cpp.pdf -- Sun Microsystems tutorial 
    https://dev.mysql.com/doc/connector-cpp/1.1/en/connector-cpp-tutorials-background.html
    https://www.youtube.com/watch?v=cSZvq7Kv6_0 -- C++ and mySQL setup
    https://dev.mysql.com/doc/connector-cpp/1.1/en/connector-cpp-getting-started-examples.html -- C++ and mySQL code examples


<S-Insert><S-Insert><S-Insert><S-Insert>

